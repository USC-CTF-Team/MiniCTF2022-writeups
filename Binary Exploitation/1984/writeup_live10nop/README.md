# Writeup: 1984
Author: Live10NOP

## Introduction
To solve this challenge we must find and exploit two vulnerabilities:
1. The first vulnerability is used to bypass address space layout randomization (ASLR)
1. The second vulnerability is used to hijack control-flow and gain code execution.
An additional requirement exists for which we must bypass a stack-canary protecting the second vulnerability.

## Reverse Engineering
The program allows us to buy up to five of three types of animals: cow, pig, and sheep.
Each bought animal is given a name.
We can also buy four lunches.
Three of these correspond to an animal type.
Buying one of these three lunches removes the last animal bought of the corresponding type.
This prints the name of the animal.

In the back end, buying an animal allocates a memory chunk of fixed size `80`.
We can then populate this chunk with up to `64` characters for the animal's name.
The pointer to this chunk is placed in the left-most open slot of a pointer array of size 5.
Each animal type has its own pointer array.
Below we show the decompiled code, created in Ghidra.
```C
if (cow_array[4] == 0) {
  for (i = 0; i < 5; i = i + 1) {
    if (cow_array[i] == 0) {
      pvVar2 = malloc(0x50);
      cow_array[i] = pvVar2;
      printf("Enter Name: ");
      read(0,(void *)cow_array[i],0x40);
      lVar1 = cow_array[i];
      sVar3 = strcspn((char *)cow_array[i],"\n");
      *(undefined *)(sVar3 + lVar1) = 0;
      return 0;
    }
  }
}
else {
  puts("The farm is already full!");
}
```

Buying lunch prints the name of the rightmost non-empty slot of the appropriate animal array, frees the memory chunk and empties the array slot.
Below we show the decompiled code, created in Ghidra.
```C
if (pig_array[0] == 0) {
  puts("Sorry, we\'re out of Pork.");
}
else {
  for (j = 4; -1 < j; j = j + -1) {
    if (pig_array[j] != 0) {
      puts("Enjoy your meal!");
      printf("Wait a sec......has anyone seen %s around lately?\n",pig_array[j]);
      free((void *)pig_array[j]);
      pig_array[j] = 0;
      break;
    }
  }
}
```

The program also allows us to "check out" and write a final message.
A new thread is spawned that `read`s from `stdin` and writes to a stack buffer.
Below we show the decompiled code, created in Ghidra.
```C
puts("Any last words to George before leaving?");
pthread_create(&local_18,(pthread_attr_t *)0x0,worker_func,(void *)0x0);
pthread_join(local_18,(void **)0x0);
--- 8< ---
/* In the worker_func function */
undefined local_28 [24];
long local_10;

local_10 = *(long *)(in_FS_OFFSET + 0x28);
read(0,local_28,0x1000);
```

## Vulnerabilities
We use the following vulnerabilities to exploit the program.

### Vulnerability 1: Information Leak
The name of an animal is read from `stdin` using the `read` function.
Then, the function `strcspn` is used with this buffer to find the first occurring instance of a newline character `\n`.
This newline character is replaced with a null character `\0`.
This is a vulnerability as `read` does not null terminate the buffer.
Therefore, if an animal name is entered that does not contain a newline character, `strcspn` will search past the entered string, until the first naturally occurring 0x0a (newline) or 0x00 (null) byte is discovered.
Consequently, when printing the animal name, whatever is adjacent to the animal name will also be printed, as it is not separated with a null byte.
This allows us to leak program memory.

### Vulnerability 2: Stack Buffer Overflow
In the function executed by the new thread spawned by the checkout functionality, there is a buffer-overflow vulnerability,
We can write up to `4096` bytes in a stack buffer of size `24`.
This allows us to overwrite the return address of the function, which can lead to control-flow hijacking.

## Bypassing ASLR
When hijacking control-flow we will redirect the program's execution to instructions selected by us.
However, because of ASLR, these instructions are located at random addresses in memory. 
We will use Vulnerability 1 to leak a `libc` memory address so that we can calculate these addresses.

We start by buying a number of animals to `malloc` a number of size `80` fast bin memory chunks.
We give these animals `64` character long names (as much as the `read` will take) to overwrite any possible existing null-bytes in memory.
Then, we `free` these chunks by buying lunches.
This overwrites the animal names with heap metadata (heap addresses).
We can leak these heap addresses with Vulnerability 1.
However, since these are heap addresses and we need a `libc` address, this does not help us much.

Instead, we first need to trigger a call to `malloc_consolidate`.
This function will take the freed fast bin memory chunks and place them into the unsorted bin.
This is useful, because chunks in this bin can contain a `libc` memory address named `main_arena`.
`malloc_consolidate` is called when memory is allocated that is too large to fit inside the small bin.
However, the program only explicitly allows us to allocate memory chunks of size `80`.
Here, we can use the `scanf` function, used to read our input and convert it into a number for option selection.
If `scanf` is given a large string, it calls `malloc` to store the string.
We use `'0' * (2 ** 26) + '1'` to select option `1` and trigger a call to `malloc_consolidate`.

Finally, we buy a number of animals and name them `\r` (which does not contain a newline character).
We sell these animals, which leaks heap meta data until we find a `libc` leak.

## Hijacking Control Flow
Vulnerability 2 allows us to overwrite the return address of the `worker_func` function, executed in a new thread by `pthread_create`.
This allows us to redirect control-flow to our chosen instructions.
However, there is a stack canary that causes the program to abort when overwritten.
We need to find a way bypass this canary.

### Bypassing the Stack Canary
When a function is called in a new thread (like `worker_func` with `pthread_create`) thread local storage (TLS) is created for this thread.
Among other things, this TLS contains the original value that stack canaries (created in the thread) are checked against, called the `stack_guard`.
The canary works in the following way:
```asm
mov    rax,QWORD PTR fs:0x28       ; stack_guard is retrieved from TLS
mov    QWORD PTR [rbp-0x8],rax     ; this value is stored on the stack to act as a canary
...
mov    rdx,QWORD PTR [rbp-0x8]     ; canary is retrieved from the stack
sub    rdx,QWORD PTR fs:0x28       ; canary is compared to the stack_guard (in TLS)
je     1366
call   1050 <__stack_chk_fail@plt> ; If the values differ, abort the program
```

The way to bypass this is to overwrite both the stack canary and the `stack_guard` with the same arbitrary value.
This is possible if we can overwrite enough data to reach the `stack_guard`.
As Vulnerability 2 allows us to overwrite up to `4096 - 24` bytes, this should be the case.

### Finding the Offset of the `stack_guard`
We find the offset of the stack guard in the following way.
We attach GDB to the process and break execution before the `read` in `worker_func`.
Then, we inspect the function stack to find the value of the canary, which will be at offset `rbp - 8`:
```
(gdb) x/1gx $rbp-8
0x7ffff7dafe48:	0x25b2c442bc676200
```
Then, we search the stack to find other instances of this value.
```
(gdb) find $rsp, +4096, 0x25b2c442bc676200
0x7ffff7dafe48
0x7ffff7dafed8
0x7ffff7db0668
3 patterns found.
```
The third one is the `stack_guard` (I discovered this after overwriting the second did not work).

### Circumventing a Segfault
If we naively overwrite a large portion of the stack to overwrite the `stack_guard`, we trigger a segmentation fault (segfault) in the function `__pthread_disable_asynccancel`.
We inspect the offending instruction:
```
(gdb) x/1i $rip
=> 0x7f1cf3dc2b62 <__pthread_disable_asynccancel+18>:	mov    BYTE PTR [rax+0x972],0x0
(gdb) i r rax
rax            0x6161616161616161  7016996765293437281
```
It turns out we overwrote an address that will be used to store a value in the function `__pthread_disable_asynccancel`.
This causes a segfault, since `0x6161616161616161` is not a writeable address.
To circumvent this, we overwrite the stack with writeable addresses for the padding to reach the `stack_guard`.
The address we leaked with Vulnerability 1 appears to be writable, so we reuse this value.

Without a working ROP chain, this still triggers a segfault, but we confirm that we have successfully hijacked control flow:
```
(gdb) x/1i $rip
=> 0x55afd3849bc1:	ret    
(gdb) x/1gx $rsp
0x7fe14d6b7e58:	0xdeadbeefdeadbeef
```
This shows we can return to an arbitrary address, `0xdeadbeefdeadbeef` in this case, which is not an executable address (hence the segfault).

## Gaining Code Execution
At this point it only comes down to creating a working ROP chain.
Since we have a `libc` leak, we can use the code in this create this chain.
As we are given the exact `libc` library used in the challenge, this is automateable with `pwntools`.
```python
libc = pwn.ELF(os.path.join(os.getcwd(), 'glibc', 'libc.so.6'))
pwn.context.binary = libc 
libc.address = libc_base

rop = pwn.ROP(libc)

bin_sh_addr = next(libc.search(b'/bin/sh'))
rop.execve(bin_sh_addr, 0, 0)
```
